#>═══════════════════════════════════════════════════════════════<#
#> ADVANCED ZOLO SYNTAX - Comprehensive Test File
#> Tests all features from ZOLO_PARSER_IMPLEMENTATION_PLAN.md
#>═══════════════════════════════════════════════════════════════<#

#>═══════════════════════════════════════════════════════════════<#
#> STRINGS - String-First Philosophy (Phase 1, 4.6b)
#>═══════════════════════════════════════════════════════════════<#

simple_string: Hello World
string_with_spaces: This has multiple   spaces
empty_string:
quotes_in_value: She said "hello" to me
single_quotes: It's a beautiful day
mixed_quotes: "What's up?" she asked
code_string: const x = "value"
nested_quotes: "outer 'inner' text"

#>═══════════════════════════════════════════════════════════════<#
#> NUMBERS - RFC 8259 Compliant (Phase 1.3)
#>═══════════════════════════════════════════════════════════════<#

# Auto-detect as float (RFC 8259 default)
port: 8080
timeout: 30
price: 99.99
scientific: 1.23e-4
negative: -42
pi: 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067

# Explicit type hints for precision control
port_int(int): 8080
timeout_int(int): 30
price_float(float): 99.99
zero(int): 0

# Number-like strings (anti-quirks)
octal_string: 00123
leading_zero: 0123
version_string: 1.0.0
big_number: 1,000,000

#>═══════════════════════════════════════════════════════════════<#
#> BOOLEANS - Explicit Type Hints Required (Phase 1.3, 5)
#>═══════════════════════════════════════════════════════════════<#

# RFC 8259 primitives → auto-detected as booleans
bool_true: true
bool_false: false

# Other boolean-like words → strings (anti-quirk, use type hints if needed)
string_yes: YES
string_no: NO
string_on: on
string_off: off

# Boolean words in sentences → always strings
bool_message: this is true
bool_status: false alarm
bool_note: yes we can
bool_answer: no way

# With type hint → actual booleans
debug(bool): true
enabled(bool): false
production(bool): true

#>═══════════════════════════════════════════════════════════════<#
#> NULL VALUES - Auto-Detect for Primitive (Phase 4.1)
#>═══════════════════════════════════════════════════════════════<#

# Null primitive (auto-detect) → None
optional_value: null
missing_data: null

# Null as part of string → always string (anti-quirk)
null_message: null value
null_description: this is null
null_status: null pointer exception
null_note: the null hypothesis
null_error: cannot be null

#>═══════════════════════════════════════════════════════════════<#
#> ARRAYS - Bracket Syntax Only (Phase 2.1)
#>═══════════════════════════════════════════════════════════════<#

# Simple arrays
tags: [python, yaml, json]
numbers: [1, 2, 3, 4, 5]
mixed: [1, hello, true, null]
booleans: [true, false, true]

# Empty and trailing commas (Phase 4.6g)
empty_array: []
trailing_comma: [a, b, c,]
empty_items: [a, , b]
just_commas: [,,,]

# Nested arrays
matrix: [[1, 2], [3, 4], [5, 6]]
deep_nested: [[[1, 2]], [[3, 4]]]

# Multi-line arrays (still bracketed)
long_list: [
    item1,
    item2,
    item3
]

#>═══════════════════════════════════════════════════════════════<#
#> OBJECTS - Nested and Flow-Style (Phase 2.3, 4.2)
#>═══════════════════════════════════════════════════════════════<#

# Nested objects (indentation-based)
database:
    host: db.example.com
    port: 5432
    credentials:
        username: admin
        password: secret123

# Flow-style objects (Phase 4.2) - IMPLEMENTED ✅
coords: {x: 10, y: 20}
empty_object: {}
numbers_obj: {port: 8080, timeout: 30, price: 99.99}
strings_obj: {name: Alice, city: NYC, status: active}
mixed_types: {id: 42, name: Bob, active: true, value: null}
typed_ints: {width(int): 1920, height(int): 1080}
typed_bools: {enabled(bool): true, debug(bool): false}
stress_test: {test(str): 123}
config_typed: {port(int): 8080, host: localhost, ssl(bool): true}
nulls_obj: {optional: null, missing: null}
nested_inline: {outer: value, inner: {nested: data}}
arrays_in_obj: {ports: [8080, 8081], tags: [web, api]}
single_key: {only: one}
many_keys: {a: 1, b: 2, c: 3, d: 4, e: 5}
whitespace_obj: {  spaced  :  value  ,  another  :  item  }

# Special characters in values
special_chars: {path: C:\Users\Admin, ratio: 16:9, range: [1-10]}
array_values: {nums: [1, 2, 3], strs: [a, b, c]}
nested_deep: {level1: {level2: {level3: {level4: value}}}}

# Mixed structures
config:
    servers:
        - prod_server
        - staging_server
    timeout: 30

#>═══════════════════════════════════════════════════════════════<#
#> MULTI-LINE STRINGS - Type Hint Required (Phase 4.6e)
#>═══════════════════════════════════════════════════════════════<#

# Multi-line with (str) hint (YAML-style indentation)
sql_query(str): SELECT name, email
    FROM users
    WHERE active = true
    ORDER BY created_at DESC

# Code block with preserved indentation
python_code(str): def hello():
    print("Hello")
    if True:
        nested()

# Documentation with blank lines
readme(str): # Project Title

    This is documentation.

    ## Features
    - Feature 1
    - Feature 2

# Inline continuation
description(str): First line
    Second line
    Third line

# WITHOUT (str) - pipe and quotes are LITERAL (Phase 4.6e)
literal_pipe: Use | for OR logic
unix_command: cat | grep pattern
bitwise: x | y

#>═══════════════════════════════════════════════════════════════<#
#> ESCAPE SEQUENCES - Permissive Approach (Phase 4.6f)
#>═══════════════════════════════════════════════════════════════<#

# Known escapes (processed)
newline_escape: Line 1\nLine 2\nLine 3
tab_escape: Name\tAge\tCity
carriage_return: Loading\rDone!
backslash_escape: C:\\Windows\\System32
quote_escape: She said \"hello\"

# Unknown escapes (preserved)
windows_path: C:\Users\Admin\Documents
regex_pattern: \d+\.\w+
latex_math: \alpha + \beta
unknown_escape: \x41\z99

# Mixed (known + unknown)
mixed_escapes: Path: C:\Windows\nNext line

#>═══════════════════════════════════════════════════════════════<#
#> UNICODE ESCAPES - RFC 8259 Compliant (Phase 4.5)
#>═══════════════════════════════════════════════════════════════<#

# Simple Unicode escapes (\uXXXX - 4 hex digits for BMP)
copyright: \u00A9 2024
cafe: Caf\u00e9
degree: 98.6\u00B0F
greater_equal: \u2265

# Extended Unicode escapes (\UXXXXXXXX - 4-8 hex digits for supplementary planes)
# Cleaner than surrogate pairs for emojis!
mobile: \U0001F4F1
laptop: \U0001F4BB
desktop: \U0001F5A5
wave: \U0001F44B
thinking: \U0001F914

# Surrogate pairs (legacy format, still supported)
wave_legacy: \uD83D\uDC4B
heart: \u2764\uFE0F

#>═══════════════════════════════════════════════════════════════<#
#> SPECIAL CHARACTERS IN VALUES (Phase 4.6a-g)
#>═══════════════════════════════════════════════════════════════<#

# Colons in values (Phase 4.6a)
url: http://example.com
api_url: https://api.example.com:8080
local: http://localhost:3000
time: 14:30:00
timestamp: 2024-01-06T14:30:00
ratio: 16:9
ipv6: fe80::1:2:3:4
docker_tag: user/repo:latest
auth_url: http://user:pass@host:8080/path

# Brackets/braces in values (Phase 4.6c)
math_expression: [1+2] equals 3
note: Use {brackets} carefully
range: values [1-10]
regex_brackets: ^[a-z]+$

# Hash in values (Phase 4.6d)
hex_color: #FF5733
hex_color2: #fffbcf
hashtag: #python
url_anchor: https://example.com#section

# zPath-like syntax (Phase 4.6e) - Treated as STRINGS in regular .zolo files
# Only in zKernel files (zUI, zSpark, etc.) are these special zPath tokens
at_path: @.logs
at_nested: @.UI.zProducts.zTheme
tilde_path: ~.config.settings
tilde_nested: ~.data.users.profile
glob_pattern: /var/log/*/error.log

# Commas in values (Phase 4.6g)
address: 123 Main St, New York, NY
formatted_number: 1,000,000
csv_header: name,age,city

#>═══════════════════════════════════════════════════════════════<#
#> TYPE HINTS - Explicit Control (Phase 1.3)
#>═══════════════════════════════════════════════════════════════<#

# Integer type hints
max_connections(int): 100
retry_count(int): 3

# Float type hints
temperature(float): 98.6
price_exact(float): 19.99

# String type hints (force string)
port_string(str): 8080
bool_string(str): true
coords_string(str): [1, 2, 3]

# Boolean type hints
is_active(bool): true
debug_mode(bool): false

# List type hints (explicit)
numbers_list(list): [1, 2, 3]

# Dict type hints (explicit) - IMPLEMENTED ✅
config_dict(dict): {x: 1, y: 2}

#>═══════════════════════════════════════════════════════════════<#
#> COMMENTS - Dual Syntax (Phase 4.6d)
#>═══════════════════════════════════════════════════════════════<#

# Full-line comments (simple #)
# This is a full-line comment
# Multiple lines of comments
# YAML-compatible

# Inline comments with arrow syntax
hex: #FF5733 #> This is a hex color <#
tag: #zolo #> Hashtags work! <#
anchor_link: section#intro #> URL anchors safe <#

# Multi-line arrow comments
value: 42 #> This is a
    multi-line comment
    spanning several lines <# after

# Unpaired markers stay literal
literal_hash: #tag1 and #tag2 are literal

#>═══════════════════════════════════════════════════════════════<#
#> EDGE CASES - Empty Values and Collections (Phase 4.1, 4.2)
#>═══════════════════════════════════════════════════════════════<#

# Empty values
empty_value:
blank:

# Empty collections
empty_list: []
empty_dict: {}
empty_nested: [[]]

# Whitespace handling
spaced_value:   content with spaces
tight_value:content
normal_value: content

#>═══════════════════════════════════════════════════════════════<#
#> COMPLEX NESTED STRUCTURES - Real-World Examples
#>═══════════════════════════════════════════════════════════════<#

application:
    name: ZoloApp
    version: 2.1.0

    server:
        host: localhost
        port(int): 8080
        ssl(bool): true
        timeout(int): 30

    database:
        primary:
            host: db1.example.com
            port(int): 5432
            credentials:
                username: admin
                password: secure_pass_123
        replica:
            host: db2.example.com
            port(int): 5432

    features:
        analytics(bool): true
        caching(bool): true
        debug(bool): false

    api_endpoints:
        - /users GET
        - /posts POST
        - /comments GET

    logging:
        level: INFO
        format(str): %(asctime)s - %(name)s - %(levelname)s
            %(message)s
        outputs: [console, file, syslog]

#>═══════════════════════════════════════════════════════════════<#
#> ANTI-QUIRKS - String-First Safety (Phase 5)
#>═══════════════════════════════════════════════════════════════<#

# These stay as strings (no YAML surprises!)
country_no: NO
country_yes: YES
switch_on: on
switch_off: off
octal_num: 00123
version_num: 1.0.0
bool_word: true
null_word: null

# Explicit booleans when needed
feature_enabled(bool): true
feature_disabled(bool): false

#>═══════════════════════════════════════════════════════════════<#
#> INDENTATION - Python-Style (Phase 4.8)
#>═══════════════════════════════════════════════════════════════<#

# Consistent indentation (spaces used throughout this file)
level_one:
    level_two:
        level_three:
            deep_value: nested content
            deep_array: [a, b, c]
        back_to_three: value
    back_to_two: value

#>═══════════════════════════════════════════════════════════════<#
#> COMPLEX NESTED MIXING - Edge Cases for Parser Testing
#>═══════════════════════════════════════════════════════════════<#

# Test 1: Nested arrays inside dash lists (CRITICAL - used in zUL/zOL)
list_with_nested_arrays:
    items:
        - First item
        - [nested_a, nested_b, nested_c]
        - Third item
        - [another, nested, array]
        - Back to simple

# Test 2: Multi-level nested arrays in dash lists
deep_nested_list:
    items:
        - Level 1 item
        - [Level 2 item, [Level 3 nested]]
        - Another L1
        - [[Fully nested], [Another nested]]

# Test 3: Objects with array properties in dash lists (CRITICAL - used in zDL)
description_list_pattern:
    items:
        - {term: Simple term, desc: Single description}
        - {term: Complex term, desc: [First description, Second description, Third description]}
        - {term: Another simple, desc: Single again}

# Test 4: Mixed dash list with objects, arrays, and strings
mixed_dash_list:
    data:
        - simple_string
        - {name: Alice, age: 30}
        - [array, of, items]
        - another_string
        - {nested: {deep: value}}
        - [[nested, array], [another, nested]]

# Test 5: Flow-style objects containing arrays in dash lists
flow_objects_in_list:
    items:
        - {id: 1, tags: [python, yaml], active: true}
        - {id: 2, tags: [javascript, json], active: false}
        - {id: 3, nested: {level: 2, items: [a, b, c]}}

# Test 6: Multiline bracket arrays with nested structures
multiline_bracket_array: [
    {key: value1, nested: [a, b]},
    [nested, array, here],
    simple_item,
    {another: object}
]

# Test 7: Deeply nested mixed syntax (block + flow + dash)
complex_hierarchy:
    users:
        - {name: Alice, roles: [admin, [read, write, execute]], config: {theme: dark, lang: en}}
        - {name: Bob, roles: [user, [read]], config: {theme: light, lang: fr}}

# Test 8: Cascading styles pattern (like zUL/zOL)
styled_list:
    style: [bullet, dash, circle]
    items:
        - Root item 1
        - Root item 2
        - [Nested level 2 item 1, Nested level 2 item 2, [Deep level 3]]
        - Root item 3

# Test 9: Triple-nested arrays
triple_nested_arrays:
    matrix: [[[1, 2]], [[3, 4]], [[5, 6]]]
    mixed: [a, [b, [c, d]], e]

# Test 10: Empty collections in dash lists
empty_collections_dash:
    items:
        - []
        - {}
        - normal_item
        - [with, items]
        - {with: props}

# Test 11: Dash lists with inline comments
commented_dash_list:
    items:
        - First item  #> This is item 1 <#
        - [nested, items]  #> Nested array <#
        - {key: value}  #> Inline object <#

# Test 12: Flow-style arrays containing flow-style objects
flow_in_flow: [{id: 1, data: [a, b]}, {id: 2, data: [c, d]}]

# Test 13: Dash list with type hints
typed_dash_list:
    items(list):
        - item1
        - item2
        - [nested, array]

# Test 14: Mixed indentation with dash and nested objects
mixed_indentation:
    config:
        servers:
            - {name: prod, specs: {cpu: 4, ram: 16}, zones: [us-east, us-west]}
            - {name: staging, specs: {cpu: 2, ram: 8}, zones: [eu-central]}

# Test 15: Edge case - single item dash list with nested array
single_dash_nested:
    items:
        - [only, nested, array]

# Test 16: Edge case - alternating nesting
alternating:
    data:
        - string
        - [array]
        - {object: value}
        - string
        - [array]
        - {object: value}

# Test 17: READABLE UX - Long paragraph content in lists (zOS/zUI use case)
# When list items contain paragraph-length content, use block dash syntax instead of inline brackets
readable_long_content:
    style: [bullet, circle, square]
    items:
        - The first principle of effective user interface design is clarity. Users should immediately understand what they can do and how to do it. This means using familiar patterns, clear labels, and intuitive navigation structures that guide users naturally through their tasks.
        - The second principle focuses on consistency across the entire application. When similar actions produce similar results and similar elements behave in similar ways, users can transfer their knowledge from one part of the system to another, reducing cognitive load and learning time.
        -
            - Nested content often requires even more explanation and context. For example, when discussing implementation details, you might need to provide code examples, explain edge cases, and describe the rationale behind certain design decisions.
            - Another nested item with substantial content. This could be a detailed explanation of an algorithm, a step-by-step tutorial, or documentation for a complex feature that requires multiple paragraphs to properly explain.
            -
                - Deeply nested items can also contain long-form content. This is particularly useful for hierarchical documentation, tutorial sequences, or breaking down complex concepts into digestible chunks while maintaining their logical relationships.
                - Additional deep content. The block dash syntax remains readable even at this level of nesting because each item starts on its own line with clear visual hierarchy through indentation.
        - Back at the root level, we continue with more substantial content. This demonstrates how the syntax gracefully handles transitions between different nesting levels while keeping everything readable and maintainable.

# Test 18: COMPARISON - Same content with inline brackets (UNREADABLE)
unreadable_inline_version:
    style: [bullet, circle, square]
    items: [The first principle of effective user interface design is clarity. Users should immediately understand what they can do and how to do it. This means using familiar patterns and clear labels and intuitive navigation structures that guide users naturally through their tasks., The second principle focuses on consistency across the entire application. When similar actions produce similar results and similar elements behave in similar ways users can transfer their knowledge from one part of the system to another reducing cognitive load and learning time., [Nested content often requires even more explanation and context. For example when discussing implementation details you might need to provide code examples explain edge cases and describe the rationale behind certain design decisions., Another nested item with substantial content. This could be a detailed explanation of an algorithm a step-by-step tutorial or documentation for a complex feature that requires multiple paragraphs to properly explain., [Deeply nested items can also contain long-form content. This is particularly useful for hierarchical documentation tutorial sequences or breaking down complex concepts into digestible chunks while maintaining their logical relationships., Additional deep content. The block dash syntax remains readable even at this level of nesting because each item starts on its own line with clear visual hierarchy through indentation.]], Back at the root level we continue with more substantial content. This demonstrates how the syntax gracefully handles transitions between different nesting levels while keeping everything readable and maintainable.]

# Test 19: HYBRID APPROACH - Short nested items use brackets, long items use dashes
hybrid_readable:
    style: [bullet, circle, square]
    items:
        - Short root item
        - Another brief item
        - This is a longer item that provides substantial information about a particular topic, explaining concepts in detail and providing context that users need to understand the full picture.
        - [Short nested 1, Short nested 2, Short nested 3]
        -
            - Long nested item that requires multiple lines of explanation to properly convey the necessary information and context for users.
            - [Brief sub-item A, Brief sub-item B]
            - Another detailed nested explanation with sufficient length to warrant the block dash format rather than cramming it into an inline bracket array.

# Test 20: READABLE zDL with paragraph-length descriptions using block arrays
readable_zdl_long_content:
    zDL:
        items: [
            {
                term: "User Interface Consistency",
                desc: [
                    "Consistency in user interface design means maintaining uniformity in visual elements, interaction patterns, and terminology across the entire application. When users encounter similar elements in different contexts, they should behave predictably, reducing cognitive load and improving usability.",
                    "This principle extends beyond just visual consistency to include behavioral consistency, where similar actions produce similar results, and conceptual consistency, where the application's underlying model remains coherent throughout the user experience."
                ]
            },
            {
                term: "Progressive Disclosure",
                desc: "Progressive disclosure is a design technique that sequences information and actions across multiple screens or steps, revealing complexity gradually as users need it. This prevents overwhelming users with too many options at once while still providing access to advanced features for power users who require them."
            }
        ]

# Test 21: UNREADABLE zDL with inline syntax (DO NOT USE THIS FOR LONG CONTENT)
unreadable_zdl_inline:
    zDL:
        items: [{term: User Interface Consistency, desc: [Consistency in user interface design means maintaining uniformity in visual elements, interaction patterns, and terminology across the entire application. When users encounter similar elements in different contexts, they should behave predictably, reducing cognitive load and improving usability., This principle extends beyond just visual consistency to include behavioral consistency, where similar actions produce similar results, and conceptual consistency, where the application's underlying model remains coherent throughout the user experience.]}, {term: Progressive Disclosure, desc: Progressive disclosure is a design technique that sequences information and actions across multiple screens or steps, revealing complexity gradually as users need it. This prevents overwhelming users with too many options at once while still providing access to advanced features for power users who require them.}]

# Test 22: HYBRID zDL - Short terms inline, long descriptions in multiline format
hybrid_zdl_readable:
    zDL:
        items: [
            {term: "API", desc: "Application Programming Interface"},
            {term: "REST", desc: "Representational State Transfer"},
            {
                term: "Microservices Architecture",
                desc: "Microservices architecture is an approach to building applications as a collection of loosely coupled, independently deployable services. Each service focuses on a specific business capability and can be developed, deployed, and scaled independently, promoting organizational agility and technical flexibility."
            },
            {term: "HTTP", desc: "Hypertext Transfer Protocol"}
        ]

# Test 23: REAL APP CONTENT - About page with readable paragraphs
about_mission:
    zH2:
        label: Our Mission
        color: PRIMARY

    zText:
        content: We believe that building applications should be as natural as writing
            documentation. Traditional programming paradigms force developers to think in
            terms of imperative instructions, managing state, and wrestling with complex
            frameworks.

    zText:
        content: Our platform takes a different approach by embracing declarative syntax
            that focuses on what you want to achieve, not how to achieve it. By combining
            the simplicity of YAML with the power of modern web technologies, we enable
            teams to build enterprise-grade applications faster and with fewer bugs.

# Test 24: REAL APP CONTENT - Feature list with paragraph explanations
about_features:
    zH2:
        label: Core Features
        color: INFO

    zUL:
        style: [circle, disc]
        items:
            - Declarative syntax that reads like natural language, making it easy for
                both developers and non-technical team members to understand application
                structure and behavior. No more cryptic variable names or complex control
                flow - just clear, intentional declarations.

            - Type-safe data modeling with automatic validation ensures that your data
                integrity is maintained at every layer of the application. Define your
                schema once, and the system handles validation, migrations, and
                referential integrity automatically.

            - Real-time collaboration features built into the core framework enable
                multiple team members to work on the same codebase simultaneously without
                conflicts. The system intelligently merges changes and provides visual
                feedback when potential conflicts arise.

            -
                - Advanced rendering engine supports both terminal and web interfaces
                    from the same source files, providing unprecedented flexibility in
                    deployment options.

                - Comprehensive theming system with handwritten typography and organic
                    design principles creates beautiful user interfaces without requiring
                    extensive CSS knowledge.

                - Built-in accessibility features ensure your applications are usable
                    by everyone, including automatic ARIA label generation, keyboard
                    navigation support, and screen reader compatibility.

# Test 25: REAL APP CONTENT - Blog post with multi-paragraph sections
blog_declarative:
    zH1:
        label: Building Declarative Applications
        color: PRIMARY

    introduction:
        zText:
            content: The software development landscape has undergone radical
                transformations over the past decade. We have witnessed the rise of
                microservices, the adoption of containerization, and the emergence of
                serverless architectures.

        zText:
            content: Yet despite these advances, building applications remains
                unnecessarily complex. Modern frameworks promise to solve this
                complexity, but often they simply shift it elsewhere. Developers spend
                more time configuring build tools, managing dependencies, and debugging
                framework internals than actually building features that matter to users.

        zText:
            content: This article explores a different approach - declarative application
                development. Instead of describing how your application should work
                through imperative code, you simply declare what you want, and the
                system figures out the rest.


# Test 26: REAL APP CONTENT - Description list with detailed explanations
blog_benefits:
    zH2:
        label: Benefits in Practice
        color: SUCCESS

    zDL:
        items: [
            {
                term: Reduced Cognitive Load,
                desc: Developers can focus on business logic rather than implementation
                    details. When you eliminate boilerplate and framework ceremony, the
                    code that remains is the code that actually matters. This dramatically
                    reduces the cognitive load required to understand and modify the system.
            },
            {
                term: Faster Development Cycles,
                desc: [
                    Declarative approaches significantly accelerate development. Features
                    that might take days to implement imperatively can often be declared
                    in hours. This speed comes from eliminating ceremony and letting the
                    framework handle the tedious details.,

                    Moreover, because declarative code has fewer moving parts, testing
                    becomes simpler. You test your specifications rather than your
                    implementations, which means tests are more focused and less brittle.
                ]
            },
            {
                term: Better Collaboration,
                desc: Declarative code bridges the gap between technical and non-technical
                    team members. Product managers can read declarations and understand what
                    the system does. Designers can modify UI specifications without fear of
                    breaking logic. QA engineers can verify behavior against explicit
                    specifications.
            }
        ]

#>═══════════════════════════════════════════════════════════════<#
#> END OF ADVANCED SYNTAX TEST
#>═══════════════════════════════════════════════════════════════<#
