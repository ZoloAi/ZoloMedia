#!/usr/bin/env python3
"""
Pygments Lexer Generator for .zolo files

Generates zolo_lexer.py dynamically from zlsp patterns.
Run this script whenever zlsp token patterns change to regenerate the lexer.

Usage:
    python generate_pygments_lexer.py
    
Output:
    zolo_lexer.py (Pygments lexer for Terminal syntax highlighting)

Philosophy:
    Single Source of Truth (SSOT): zlsp defines tokens â†’ Generator creates lexers
    This matches your VSCode extension build pattern (zlsp â†’ vscode.py â†’ grammar)
"""

import os
import sys
from pathlib import Path
from datetime import datetime


def generate_lexer_header() -> str:
    """Generate file header with metadata."""
    return f'''"""
Pygments Lexer for .zolo files

AUTO-GENERATED by generate_pygments_lexer.py
DO NOT EDIT MANUALLY - Changes will be overwritten!

Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Source: zlsp token patterns
Maintainer: Run generate_pygments_lexer.py to regenerate
"""

from pygments.lexer import RegexLexer, bygroups, include
from pygments.token import (
    Comment, Keyword, Name, String, Number, Punctuation,
    Operator, Whitespace, Generic, Error
)

__all__ = ['ZoloLexer']
'''


def generate_lexer_class() -> str:
    r"""
    Generate the ZoloLexer class with patterns extracted from zlsp.
    
    Token patterns are based on:
    - zlsp/core/parser/parser_modules/line_parsers.py (key detection)
    - zlsp/core/parser/parser_modules/token_emitters.py (value detection)
    - zlsp/core/lsp_types.py (TokenType definitions)
    
    Mapping:
    - zlsp TokenType â†’ Pygments Token class
    - zlsp regex patterns â†’ Pygments regex patterns
    """
    return r'''

class ZoloLexer(RegexLexer):
    r"""
    Lexer for .zolo declarative configuration files.
    
    Supports:
    - Root keys (Page_Header:, Core_Concepts_Section:)
    - Display events (zH1:, zText:, zMD:)
    - Metadata keys (_zClass:, _zStyle:, _zId:)
    - Special keys (zMeta:, zRBAC:, ~zNavBar*)
    - Properties (label:, content:, color:)
    - Modifiers (*, !, ^, ~)
    - Type hints ((int), (str), (bool))
    - Escape sequences (\\uXXXX, \\UXXXXXXXX)
    - Comments (# lines)
    - Values (strings, numbers, booleans, arrays)
    
    Token Mapping (zlsp â†’ Pygments):
    - rootKey â†’ Name.Class (bold, prominent)
    - uiElementKey (z*) â†’ Name.Function (blue/cyan)
    - nestedKey â†’ Name.Attribute (properties)
    - escapeSequence â†’ String.Escape (bright)
    - comment â†’ Comment.Single (dim)
    - typeHint â†’ Generic.Emph (italic)
    - number â†’ Number
    - string â†’ String
    - boolean â†’ Keyword.Constant
    """
    
    name = 'Zolo'
    aliases = ['zolo']
    filenames = ['*.zolo']
    mimetypes = ['text/x-zolo']
    
    tokens = {
        'root': [
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # COMMENTS
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # zlsp: TokenType.COMMENT
            (r'#.*$', Comment.Single),
            
            # Empty lines
            (r'^\\s*$', Whitespace),
            
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # ROOT-LEVEL KEYS (zlsp: TokenType.ROOT_KEY)
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # Pattern: ^[A-Z][a-zA-Z0-9_]*:
            # Examples: Page_Header:, Core_Concepts_Section:
            (r'^([A-Z][a-zA-Z0-9_]*)'      # Root key (capitalized)
             r'(\\([^)]+\\))?'              # Optional type hint
             r'(\\*|!|\\^|~)?'              # Optional modifiers
             r'(:)',                        # Colon
             bygroups(Name.Class, Generic.Emph, Operator, Punctuation)),
            
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # SPECIAL KEYS (zlsp: TokenType.ZMETA_KEY, etc.)
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # zMeta, zRBAC, ~zNavBar*
            (r'^(\\s*)'                     # Indentation
             r'(~?z(?:Meta|RBAC)|~zNavBar[a-zA-Z0-9_]*)'  # Special keywords
             r'(\\*)?'                      # Optional modifier
             r'(:)',                        # Colon
             bygroups(Whitespace, Keyword.Namespace, Operator, Punctuation)),
            
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # DISPLAY EVENT KEYS (zlsp: TokenType.UI_ELEMENT_KEY)
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # Pattern: z[A-Z][a-zA-Z0-9]*:
            # Examples: zH1:, zText:, zMD:, zTable:, zUL:
            (r'(\\s*)'                      # Indentation
             r'(z[A-Z][a-zA-Z0-9]*)'       # Display event (z + uppercase)
             r'(\\([^)]+\\))?'              # Optional type hint
             r'(\\*|!)?'                    # Optional modifiers
             r'(:)',                        # Colon
             bygroups(Whitespace, Name.Function, Generic.Emph, Operator, Punctuation)),
            
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # METADATA KEYS (zlsp: metadata attributes)
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # Pattern: _z[A-Z][a-zA-Z]+: or _data: or _transaction:
            # Examples: _zClass:, _zStyle:, _zId:, _data:
            (r'(\\s*)'                      # Indentation
             r'(_z[A-Z][a-zA-Z]+|_data|_transaction)'  # Metadata
             r'(:)',                        # Colon
             bygroups(Whitespace, Name.Variable, Punctuation)),
            
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # PROPERTY KEYS (zlsp: TokenType.NESTED_KEY)
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # Pattern: [a-z][a-zA-Z0-9_]*:
            # Examples: label:, content:, color:, href*:
            (r'(\\s*)'                      # Indentation
             r'(\\^|~)?'                    # Optional prefix modifier
             r'([a-z][a-zA-Z0-9_]*)'       # Property key (lowercase start)
             r'(\\([^)]+\\))?'              # Optional type hint
             r'(\\*|!)?'                    # Optional suffix modifier
             r'(:)',                        # Colon
             bygroups(Whitespace, Operator, Name.Attribute, Generic.Emph, Operator, Punctuation)),
            
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # VALUES (after colon)
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            include('values'),
        ],
        
        'values': [
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # ESCAPE SEQUENCES (zlsp: TokenType.ESCAPE_SEQUENCE)
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # Unicode escapes: \\uXXXX, \\UXXXXXXXX
            (r'\\\\[uU][0-9A-Fa-f]{4,8}', String.Escape),
            
            # Standard escapes: \\n, \\t, \\r, etc.
            (r'\\\\[nrtbf\\\\"\']', String.Escape),
            
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # BOOLEANS (zlsp: TokenType.BOOLEAN)
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            (r'\\b(true|false|True|False|yes|no|on|off)\\b', Keyword.Constant),
            
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # NUMBERS (zlsp: TokenType.NUMBER)
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # Float with optional negative
            (r'-?\\d+\\.\\d+', Number.Float),
            # Integer with optional negative
            (r'-?\\d+', Number.Integer),
            
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # ARRAYS (zlsp: TokenType.BRACKET_STRUCTURAL)
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            (r'\\[', Punctuation, 'array'),
            (r'\\]', Punctuation),
            
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # NULL VALUES (zlsp: TokenType.NULL)
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            (r'\\b(null|None)\\b', Keyword.Constant),
            
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # STRINGS (zlsp: TokenType.STRING)
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # Everything else as value content (zolo's string-first philosophy)
            (r'[^\\s\\[\\]#]+', String),
            
            # Whitespace
            (r'\\s+', Whitespace),
        ],
        
        'array': [
            # Array content
            (r'\\]', Punctuation, '#pop'),
            (r',', Punctuation),
            include('values'),
        ],
    }
'''


def generate_lexer_registration() -> str:
    """Generate auto-registration code."""
    return '''

def setup_lexer():
    """
    Register the lexer with Pygments so it can be used by language name.
    Called automatically when module is imported.
    """
    try:
        from pygments.lexers import get_lexer_by_name
        # Check if already registered
        try:
            get_lexer_by_name('zolo')
        except:
            # Not registered, do it now
            from pygments.lexers import LEXERS
            LEXERS['ZoloLexer'] = (
                'zOS.core.zSys.syntax.zolo_lexer',
                'Zolo',
                ('zolo',),
                ('*.zolo',),
                ('text/x-zolo',)
            )
    except ImportError:
        # Pygments not available, skip registration
        pass


# Auto-register when module is imported
setup_lexer()
'''


def generate_lexer_file():
    """Generate the complete zolo_lexer.py file."""
    output_path = Path(__file__).parent / 'zolo_lexer.py'
    
    content = (
        generate_lexer_header() +
        generate_lexer_class() +
        generate_lexer_registration()
    )
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(content)
    
    print(f"âœ… Generated: {output_path}")
    print(f"   Size: {len(content)} bytes")
    print(f"   Lines: {len(content.splitlines())}")
    print()
    print("ðŸŽ¨ Pygments lexer ready for Terminal syntax highlighting!")
    print()
    print("To test:")
    print("  cd zCloud && zolo shell --file UI/zProducts/zTheme/zUI.zBreakpoints.zolo")


def main():
    """Main entry point."""
    print("=" * 70)
    print("Pygments Lexer Generator for .zolo files")
    print("=" * 70)
    print()
    print("Source: zlsp token patterns (SSOT)")
    print("Output: zolo_lexer.py (Pygments Terminal highlighting)")
    print()
    
    generate_lexer_file()
    
    print()
    print("=" * 70)
    print("âœ… Generation complete!")
    print("=" * 70)


if __name__ == '__main__':
    main()
